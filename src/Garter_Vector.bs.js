// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Garter_Array = require("./Garter_Array.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");

function hasRoom(node) {
  return node._0.length < 32;
}

function hasSiblings(node) {
  return node._0.length > 1;
}

function makeNode2(x, y) {
  var ar = new Array(2);
  ar[0] = x;
  ar[1] = y;
  return {
          TAG: /* Node */0,
          _0: ar
        };
}

function clone(ar) {
  if (ar.TAG) {
    return {
            TAG: /* Leaf */1,
            _0: ar._0.slice(0)
          };
  } else {
    return {
            TAG: /* Node */0,
            _0: ar._0.slice(0)
          };
  }
}

function setNode(node, idx, v) {
  if (!node.TAG) {
    node._0[idx] = v;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Garter_Vector.re",
          56,
          17
        ],
        Error: new Error()
      };
}

function make(param) {
  return {
          size: 0,
          depth: 1,
          root: {
            TAG: /* Leaf */1,
            _0: []
          }
        };
}

function length(v) {
  return v.size;
}

function pow(base, exp) {
  return Math.pow(base, exp) | 0;
}

function getPathIdx(i, depth) {
  if (depth === 1) {
    return {
            hd: i,
            tl: /* [] */0
          };
  }
  var denom = pow(32, depth - 1 | 0);
  return Belt_List.add(getPathIdx(Caml_int32.mod_(i, denom), depth - 1 | 0), Caml_int32.div(i, denom));
}

function getUnsafe(param, i) {
  var path = getPathIdx(i, param.depth);
  var _path = path;
  var _node = param.root;
  while(true) {
    var node = _node;
    var path$1 = _path;
    var index = Belt_List.headExn(path$1);
    if (node.TAG) {
      return node._0[index];
    }
    _node = node._0[index];
    _path = Belt_List.tailExn(path$1);
    continue ;
  };
}

function get(v, i) {
  if (i < 0 || i >= v.size) {
    return ;
  } else {
    return Caml_option.some(getUnsafe(v, i));
  }
}

function setUnsafe(vec, i, x) {
  var path = getPathIdx(i, vec.depth);
  var traverse = function (path, node) {
    var index = Belt_List.headExn(path);
    if (node.TAG) {
      var m = node._0.slice(0);
      m[index] = x;
      return {
              TAG: /* Leaf */1,
              _0: m
            };
    }
    var n = node._0;
    var m$1 = n.slice(0);
    m$1[index] = traverse(Belt_List.tailExn(path), n[index]);
    return {
            TAG: /* Node */0,
            _0: m$1
          };
  };
  return {
          size: vec.size,
          depth: vec.depth,
          root: traverse(path, vec.root)
        };
}

function getTail(param) {
  var path = getPathIdx(param.size - 1 | 0, param.depth);
  var _path = path;
  var _node = param.root;
  while(true) {
    var node = _node;
    var path$1 = _path;
    var subIdx = Belt_List.headExn(path$1);
    if (node.TAG) {
      return node;
    }
    _node = node._0[subIdx];
    _path = Belt_List.tailExn(path$1);
    continue ;
  };
}

var logging = {
  contents: false
};

function log2(x, y) {
  if (logging.contents) {
    console.info(x, y);
    return ;
  }
  
}

function push(vec, x) {
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  if (hasRoom(getTail(vec))) {
    var traverse = function (node) {
      if (node.TAG) {
        var ar = node._0;
        var newAr = ar.slice(0);
        newAr[ar.length] = x;
        return {
                TAG: /* Leaf */1,
                _0: newAr
              };
      }
      var ar$1 = node._0;
      var newAr$1 = ar$1.slice(0);
      newAr$1[ar$1.length - 1 | 0] = traverse(Garter_Array.lastUnsafe(ar$1));
      return {
              TAG: /* Node */0,
              _0: newAr$1
            };
    };
    var newRoot = traverse(root);
    return {
            size: size + 1 | 0,
            depth: vec.depth,
            root: newRoot
          };
  }
  var isRootOverflow = size === pow(32, depth);
  var newPath = function (_depth, _node) {
    while(true) {
      var node = _node;
      var depth = _depth;
      if (depth === 0) {
        return node;
      }
      _node = {
        TAG: /* Node */0,
        _0: Belt_Array.make(1, node)
      };
      _depth = depth - 1 | 0;
      continue ;
    };
  };
  if (isRootOverflow) {
    var newRoot$1 = makeNode2(root, newPath(depth - 1 | 0, {
              TAG: /* Leaf */1,
              _0: Belt_Array.make(1, x)
            }));
    return {
            size: size + 1 | 0,
            depth: depth + 1 | 0,
            root: newRoot$1
          };
  }
  var pushTail = function (depth, parent, path) {
    var ret = clone(parent);
    var subIdx = Belt_List.headExn(path);
    if (depth === 2) {
      setNode(ret, subIdx, {
            TAG: /* Leaf */1,
            _0: Belt_Array.make(1, x)
          });
      return ret;
    }
    if (parent.TAG) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Garter_Vector.re",
              235,
              25
            ],
            Error: new Error()
          };
    }
    var ar = parent._0;
    var newChild;
    if (subIdx < ar.length) {
      var child = ar[subIdx];
      newChild = pushTail(depth - 1 | 0, child, Belt_List.tailExn(path));
    } else {
      newChild = newPath(depth - 2 | 0, {
            TAG: /* Leaf */1,
            _0: Belt_Array.make(1, x)
          });
    }
    setNode(ret, subIdx, newChild);
    return ret;
  };
  var path = getPathIdx(size, depth);
  var newRoot$2 = pushTail(depth, root, path);
  return {
          size: size + 1 | 0,
          depth: vec.depth,
          root: newRoot$2
        };
}

function peek(v) {
  var ar = getTail(v);
  if (ar.TAG) {
    var ar$1 = ar._0;
    return Belt_Array.get(ar$1, ar$1.length - 1 | 0);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Garter_Vector.re",
          249,
          15
        ],
        Error: new Error()
      };
}

function pop(vec) {
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  if (hasSiblings(getTail(vec))) {
    log2("[pop case1]", peek(vec));
    var traverse = function (parent) {
      if (parent.TAG) {
        var ar = parent._0;
        var newAr = Belt_Array.slice(ar, 0, ar.length - 1 | 0);
        return {
                TAG: /* Leaf */1,
                _0: newAr
              };
      }
      var ar$1 = parent._0;
      var newAr$1 = ar$1.slice(0);
      newAr$1[ar$1.length - 1 | 0] = traverse(Garter_Array.lastUnsafe(ar$1));
      return {
              TAG: /* Node */0,
              _0: newAr$1
            };
    };
    var newRoot = traverse(root);
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: newRoot
          };
  }
  log2("[pop case2&3]", peek(vec));
  var popTail = function (parent, path) {
    var subIdx = Belt_List.headExn(path);
    if (parent.TAG) {
      if (subIdx !== 0) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Garter_Vector.re",
                298,
                10
              ],
              Error: new Error()
            };
      }
      return ;
    }
    var ar = parent._0;
    var child = popTail(ar[subIdx], Belt_List.tailExn(path));
    if (child !== undefined) {
      var newAr = ar.slice(0);
      newAr[subIdx] = child;
      return {
              TAG: /* Node */0,
              _0: newAr
            };
    }
    if (subIdx === 0) {
      return ;
    }
    var newAr$1 = Belt_Array.slice(ar, 0, ar.length - 1 | 0);
    return {
            TAG: /* Node */0,
            _0: newAr$1
          };
  };
  var path = getPathIdx(size - 1 | 0, depth);
  var newRoot$1 = popTail(root, path);
  if (newRoot$1 !== undefined) {
    if (!newRoot$1.TAG && !hasSiblings(newRoot$1)) {
      var firstChild = newRoot$1._0[0];
      return {
              size: size - 1 | 0,
              depth: depth - 1 | 0,
              root: firstChild
            };
    }
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: newRoot$1
          };
  }
  if (size !== 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.re",
            316,
            8
          ],
          Error: new Error()
        };
  }
  return {
          size: 0,
          depth: 1,
          root: {
            TAG: /* Leaf */1,
            _0: []
          }
        };
}

function fromArray(ar) {
  return Belt_Array.reduce(ar, {
              size: 0,
              depth: 1,
              root: {
                TAG: /* Leaf */1,
                _0: []
              }
            }, push);
}

function toArray(param) {
  var data = [];
  var traverse = function (node) {
    if (!node.TAG) {
      return Belt_Array.forEach(node._0, traverse);
    }
    Caml_splice_call.spliceObjApply(data, "push", [node._0]);
    
  };
  traverse(param.root);
  return data;
}

function debug(param) {
  var traverse = function (node, depth) {
    if (node.TAG) {
      console.log("L " + String(depth));
      return Belt_Array.forEach(node._0, (function (n) {
                    console.log(n);
                    
                  }));
    }
    console.log("I " + String(depth));
    return Belt_Array.forEach(node._0, (function (n) {
                  return traverse(n, depth + 1 | 0);
                }));
  };
  return traverse(param.root, 1);
}

exports.make = make;
exports.length = length;
exports.push = push;
exports.pop = pop;
exports.peek = peek;
exports.get = get;
exports.getUnsafe = getUnsafe;
exports.setUnsafe = setUnsafe;
exports.fromArray = fromArray;
exports.toArray = toArray;
exports.debug = debug;
/* No side effect */
