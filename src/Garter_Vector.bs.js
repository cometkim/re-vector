// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");

function hasSiblings(node) {
  return node._0.length > 1;
}

function makeNode2(x, y) {
  var ar = new Array(2);
  ar[0] = x;
  ar[1] = y;
  return {
          TAG: /* Node */0,
          _0: ar
        };
}

function clone(x) {
  if (x.TAG === /* Node */0) {
    return {
            TAG: /* Node */0,
            _0: x._0.slice(0)
          };
  } else {
    return {
            TAG: /* Leaf */1,
            _0: x._0.slice(0)
          };
  }
}

function setNode(node, idx, v) {
  if (node.TAG === /* Node */0) {
    node._0[idx] = v;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Garter_Vector.res",
          34,
          17
        ],
        Error: new Error()
      };
}

function make(param) {
  return {
          size: 0,
          depth: 1,
          root: {
            TAG: /* Node */0,
            _0: []
          },
          tail: []
        };
}

function length(v) {
  return v.size;
}

function pow(base, exp) {
  return Math.pow(base, exp) | 0;
}

function getPathIdx(i, depth) {
  if (depth === 0) {
    return /* [] */0;
  }
  var denom = pow(32, depth);
  return Belt_List.add(getPathIdx(Caml_int32.mod_(i, denom), depth - 1 | 0), Caml_int32.div(i, denom));
}

function push(vec, x) {
  var tail = vec.tail;
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  if (tail.length < 32) {
    var newTail = tail.slice(0);
    newTail[tail.length] = x;
    return {
            size: size + 1 | 0,
            depth: vec.depth,
            root: vec.root,
            tail: newTail
          };
  }
  var isRootOverflow = size === (pow(32, depth + 1 | 0) + 32 | 0);
  var newPath = function (_depth, _node) {
    while(true) {
      var node = _node;
      var depth = _depth;
      if (depth === 0) {
        return node;
      }
      _node = {
        TAG: /* Node */0,
        _0: Belt_Array.make(1, node)
      };
      _depth = depth - 1 | 0;
      continue ;
    };
  };
  if (isRootOverflow) {
    var newRoot = makeNode2(root, newPath(depth, {
              TAG: /* Leaf */1,
              _0: tail
            }));
    return {
            size: size + 1 | 0,
            depth: depth + 1 | 0,
            root: newRoot,
            tail: [x]
          };
  }
  var pushTail = function (depth, parent, path) {
    var ret = clone(parent);
    var subIdx = Belt_List.headExn(path);
    if (depth === 1) {
      setNode(ret, subIdx, {
            TAG: /* Leaf */1,
            _0: tail
          });
      return ret;
    }
    if (parent.TAG === /* Node */0) {
      var ar = parent._0;
      var newChild = subIdx < ar.length ? pushTail(depth - 1 | 0, Caml_array.get(ar, subIdx), Belt_List.tailExn(path)) : newPath(depth - 1 | 0, {
              TAG: /* Leaf */1,
              _0: tail
            });
      setNode(ret, subIdx, newChild);
      return ret;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.res",
            103,
            23
          ],
          Error: new Error()
        };
  };
  var tailOffset = size - tail.length | 0;
  var path = getPathIdx(tailOffset, depth);
  var newRoot$1 = pushTail(depth, root, path);
  return {
          size: size + 1 | 0,
          depth: vec.depth,
          root: newRoot$1,
          tail: [x]
        };
}

function peek(param) {
  var tail = param.tail;
  return Belt_Array.get(tail, tail.length - 1 | 0);
}

function pop(vec) {
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  if (hasSiblings({
          TAG: /* Leaf */1,
          _0: vec.tail
        })) {
    var traverse = function (parent) {
      if (parent.TAG === /* Node */0) {
        var ar = parent._0;
        var newAr = ar.slice(0);
        var subIdx = ar.length - 1 | 0;
        newAr[subIdx] = traverse(ar[subIdx]);
        return {
                TAG: /* Node */0,
                _0: newAr
              };
      }
      var ar$1 = parent._0;
      var newAr$1 = Belt_Array.slice(ar$1, 0, ar$1.length - 1 | 0);
      return {
              TAG: /* Leaf */1,
              _0: newAr$1
            };
    };
    var newRoot = traverse(root);
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: newRoot,
            tail: vec.tail
          };
  }
  var popTail = function (parent, path) {
    var subIdx = Belt_List.headExn(path);
    if (parent.TAG === /* Node */0) {
      var ar = parent._0;
      var child = popTail(Caml_array.get(ar, subIdx), Belt_List.tailExn(path));
      if (child !== undefined) {
        var newAr = ar.slice(0);
        newAr[subIdx] = child;
        return {
                TAG: /* Node */0,
                _0: newAr
              };
      }
      if (subIdx === 0) {
        return ;
      }
      var newAr$1 = Belt_Array.slice(ar, 0, ar.length - 1 | 0);
      return {
              TAG: /* Node */0,
              _0: newAr$1
            };
    }
    if (subIdx !== 0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Garter_Vector.res",
              160,
              8
            ],
            Error: new Error()
          };
    }
    
  };
  var path = getPathIdx(size - 1 | 0, depth);
  var newRoot$1 = popTail(root, path);
  if (newRoot$1 !== undefined) {
    if (newRoot$1.TAG === /* Node */0 && !hasSiblings(newRoot$1)) {
      var firstChild = Caml_array.get(newRoot$1._0, 0);
      return {
              size: size - 1 | 0,
              depth: depth - 1 | 0,
              root: firstChild,
              tail: vec.tail
            };
    }
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: newRoot$1,
            tail: vec.tail
          };
  }
  if (size !== 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.res",
            178,
            6
          ],
          Error: new Error()
        };
  }
  return make(undefined);
}

function getExn(param, i) {
  var path = getPathIdx(i, param.depth);
  var _path = path;
  var _node = param.root;
  while(true) {
    var node = _node;
    var path$1 = _path;
    var index = Belt_List.headExn(path$1);
    if (node.TAG !== /* Node */0) {
      return Caml_array.get(node._0, index);
    }
    _node = Caml_array.get(node._0, index);
    _path = Belt_List.tailExn(path$1);
    continue ;
  };
}

function get(v, i) {
  if (i < 0 || i >= v.size) {
    return ;
  } else {
    return Caml_option.some(getExn(v, i));
  }
}

function setExn(vec, i, x) {
  var traverse = function (path, node) {
    var index = Belt_List.headExn(path);
    if (node.TAG === /* Node */0) {
      var ar = node._0;
      var m = ar.slice(0);
      m[index] = traverse(Belt_List.tailExn(path), Caml_array.get(ar, index));
      return {
              TAG: /* Node */0,
              _0: m
            };
    }
    var m$1 = node._0.slice(0);
    m$1[index] = x;
    return {
            TAG: /* Leaf */1,
            _0: m$1
          };
  };
  var path = getPathIdx(i, vec.depth);
  return {
          size: vec.size,
          depth: vec.depth,
          root: traverse(path, vec.root),
          tail: vec.tail
        };
}

function set(vec, i, x) {
  if (i < 0 || i >= vec.size) {
    return ;
  } else {
    return setExn(vec, i, x);
  }
}

function fromArray(ar) {
  return Belt_Array.reduce(ar, make(undefined), push);
}

function toArray(param) {
  var data = [];
  var traverse = function (node) {
    if (node.TAG === /* Node */0) {
      return Belt_Array.forEach(node._0, traverse);
    }
    Caml_splice_call.spliceObjApply(data, "push", [node._0]);
    
  };
  traverse(param.root);
  return data;
}

function map(vec, f) {
  return fromArray(Belt_Array.map(toArray(vec), f));
}

function keep(vec, f) {
  return fromArray(Belt_Array.keep(toArray(vec), f));
}

function reduce(vec, init, f) {
  return Belt_Array.reduce(toArray(vec), init, f);
}

function debug(param) {
  var traverse = function (node, depth) {
    if (node.TAG === /* Node */0) {
      console.log("I " + String(depth));
      return Belt_Array.forEach(node._0, (function (n) {
                    return traverse(n, depth + 1 | 0);
                  }));
    }
    console.log("L " + String(depth));
    return Belt_Array.forEach(node._0, (function (n) {
                  console.log(n);
                  
                }));
  };
  return traverse(param.root, 1);
}

exports.make = make;
exports.length = length;
exports.push = push;
exports.pop = pop;
exports.peek = peek;
exports.get = get;
exports.getExn = getExn;
exports.set = set;
exports.setExn = setExn;
exports.map = map;
exports.keep = keep;
exports.reduce = reduce;
exports.fromArray = fromArray;
exports.toArray = toArray;
exports.debug = debug;
/* No side effect */
