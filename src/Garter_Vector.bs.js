// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function makeNode2(x, y) {
  var ar = new Array(2);
  ar[0] = x;
  ar[1] = y;
  return {
          TAG: /* Node */0,
          _0: ar
        };
}

function clone(x) {
  if (x.TAG === /* Node */0) {
    return {
            TAG: /* Node */0,
            _0: x._0.slice(0)
          };
  } else {
    return {
            TAG: /* Leaf */1,
            _0: x._0.slice(0)
          };
  }
}

function setNode(node, idx, v) {
  if (node.TAG === /* Node */0) {
    node._0[idx] = v;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Garter_Vector.res",
          30,
          17
        ],
        Error: new Error()
      };
}

function make(param) {
  return {
          size: 0,
          depth: 1,
          root: {
            TAG: /* Node */0,
            _0: []
          },
          tail: []
        };
}

function length(v) {
  return v.size;
}

function pow(base, exp) {
  return Math.pow(base, exp) | 0;
}

function getPathIdx(i, depth) {
  if (depth === 0) {
    return /* [] */0;
  }
  var denom = pow(32, depth);
  return Belt_List.add(getPathIdx(Caml_int32.mod_(i, denom), depth - 1 | 0), Caml_int32.div(i, denom));
}

function tailOffset(param) {
  return param.size - param.tail.length | 0;
}

function push(vec, x) {
  var tail = vec.tail;
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  if (tail.length < 32) {
    var newTail = tail.slice(0);
    newTail[tail.length] = x;
    return {
            size: size + 1 | 0,
            depth: vec.depth,
            root: vec.root,
            tail: newTail
          };
  }
  var isRootOverflow = size === (pow(32, depth + 1 | 0) + 32 | 0);
  var newPath = function (_depth, _node) {
    while(true) {
      var node = _node;
      var depth = _depth;
      if (depth === 0) {
        return node;
      }
      _node = {
        TAG: /* Node */0,
        _0: Belt_Array.make(1, node)
      };
      _depth = depth - 1 | 0;
      continue ;
    };
  };
  if (isRootOverflow) {
    var newRoot = makeNode2(root, newPath(depth, {
              TAG: /* Leaf */1,
              _0: tail
            }));
    return {
            size: size + 1 | 0,
            depth: depth + 1 | 0,
            root: newRoot,
            tail: [x]
          };
  }
  var pushTail = function (depth, parent, path) {
    var ret = clone(parent);
    var subIdx = Belt_List.headExn(path);
    if (depth === 1) {
      setNode(ret, subIdx, {
            TAG: /* Leaf */1,
            _0: tail
          });
      return ret;
    }
    if (parent.TAG === /* Node */0) {
      var ar = parent._0;
      var newChild = subIdx < ar.length ? pushTail(depth - 1 | 0, Caml_array.get(ar, subIdx), Belt_List.tailExn(path)) : newPath(depth - 1 | 0, {
              TAG: /* Leaf */1,
              _0: tail
            });
      setNode(ret, subIdx, newChild);
      return ret;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.res",
            102,
            23
          ],
          Error: new Error()
        };
  };
  var path = getPathIdx(tailOffset(vec), depth);
  var newRoot$1 = pushTail(depth, root, path);
  return {
          size: size + 1 | 0,
          depth: vec.depth,
          root: newRoot$1,
          tail: [x]
        };
}

function peek(param) {
  var tail = param.tail;
  return Belt_Array.get(tail, tail.length - 1 | 0);
}

function getArrayUnsafe(vec, idx) {
  if (idx >= tailOffset(vec)) {
    return vec.tail;
  }
  var traverse = function (_parent, _path) {
    while(true) {
      var path = _path;
      var parent = _parent;
      if (!path) {
        return parent;
      }
      if (parent.TAG === /* Node */0) {
        _path = path.tl;
        _parent = Caml_array.get(parent._0, path.hd);
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Garter_Vector.res",
              127,
              21
            ],
            Error: new Error()
          };
    };
  };
  var path = getPathIdx(idx, vec.depth);
  var ar = traverse(vec.root, path);
  if (ar.TAG !== /* Node */0) {
    return ar._0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Garter_Vector.res",
          132,
          17
        ],
        Error: new Error()
      };
}

function pop(vec) {
  var tail = vec.tail;
  var depth = vec.depth;
  var size = vec.size;
  if (size === 1) {
    return make(undefined);
  }
  if (tail.length > 1) {
    var newTail = Belt_Array.slice(tail, 0, tail.length - 1 | 0);
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: vec.root,
            tail: newTail
          };
  }
  var popTail = function (depth, parent, path) {
    if (!path) {
      return ;
    }
    var subIdx = path.hd;
    if (parent.TAG === /* Node */0) {
      var ar = parent._0;
      var child = popTail(depth - 1 | 0, Caml_array.get(ar, subIdx), path.tl);
      if (child !== undefined) {
        var newAr = ar.slice(0);
        newAr[subIdx] = child;
        return {
                TAG: /* Node */0,
                _0: newAr
              };
      }
      if (subIdx === 0) {
        return ;
      }
      var newAr$1 = Belt_Array.slice(ar, 0, ar.length - 1 | 0);
      return {
              TAG: /* Node */0,
              _0: newAr$1
            };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.res",
            173,
            21
          ],
          Error: new Error()
        };
  };
  var path = getPathIdx(size - 2 | 0, depth);
  var newTail$1 = getArrayUnsafe(vec, size - 2 | 0);
  var nr = popTail(depth, vec.root, path);
  var newRoot = nr !== undefined ? nr : ({
        TAG: /* Node */0,
        _0: []
      });
  if (newRoot.TAG === /* Node */0) {
    var ar = newRoot._0;
    var isRootUnderflow = depth > 1 && ar.length === 1;
    if (isRootUnderflow) {
      return {
              size: size - 1 | 0,
              depth: depth - 1 | 0,
              root: Caml_array.get(ar, 0),
              tail: newTail$1
            };
    } else {
      return {
              size: size - 1 | 0,
              depth: vec.depth,
              root: newRoot,
              tail: newTail$1
            };
    }
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Garter_Vector.res",
          192,
          17
        ],
        Error: new Error()
      };
}

function getExn(vec, i) {
  var offset = tailOffset(vec);
  if (i >= offset) {
    return Caml_array.get(vec.tail, i - offset | 0);
  }
  var path = getPathIdx(i, vec.depth);
  var _node = vec.root;
  var _path = path;
  while(true) {
    var path$1 = _path;
    var node = _node;
    if (node.TAG !== /* Node */0) {
      return Caml_array.get(node._0, i % 32);
    }
    _path = Belt_List.tailExn(path$1);
    _node = Caml_array.get(node._0, Belt_List.headExn(path$1));
    continue ;
  };
}

function get(v, i) {
  if (i < 0 || i >= v.size) {
    return ;
  } else {
    return Caml_option.some(getExn(v, i));
  }
}

function setExn(vec, i, x) {
  var offset = tailOffset(vec);
  if (i >= offset) {
    var newTail = vec.tail.slice(0);
    newTail[i - offset | 0] = x;
    return {
            size: vec.size,
            depth: vec.depth,
            root: vec.root,
            tail: newTail
          };
  }
  var traverse = function (node, path) {
    if (node.TAG === /* Node */0) {
      var ar = node._0;
      var index = Belt_List.headExn(path);
      var m = ar.slice(0);
      m[index] = traverse(Caml_array.get(ar, index), Belt_List.tailExn(path));
      return {
              TAG: /* Node */0,
              _0: m
            };
    }
    var m$1 = node._0.slice(0);
    m$1[i % 32] = x;
    return {
            TAG: /* Leaf */1,
            _0: m$1
          };
  };
  var path = getPathIdx(i, vec.depth);
  return {
          size: vec.size,
          depth: vec.depth,
          root: traverse(vec.root, path),
          tail: vec.tail
        };
}

function set(vec, i, x) {
  if (i < 0 || i >= vec.size) {
    return ;
  } else {
    return setExn(vec, i, x);
  }
}

function fromArray(ar) {
  return Belt_Array.reduce(ar, make(undefined), push);
}

function toArray(param) {
  var tail = param.tail;
  var data = new Array(param.size);
  var idx = {
    contents: 0
  };
  var fromTree = function (node) {
    if (node.TAG === /* Node */0) {
      return Belt_Array.forEach(node._0, fromTree);
    }
    var ar = node._0;
    var len = ar.length;
    Belt_Array.blitUnsafe(ar, 0, data, idx.contents, len);
    idx.contents = idx.contents + len | 0;
    
  };
  fromTree(param.root);
  Belt_Array.blitUnsafe(tail, 0, data, idx.contents, tail.length);
  return data;
}

function map(vec, f) {
  return fromArray(Belt_Array.map(toArray(vec), f));
}

function keep(vec, f) {
  return fromArray(Belt_Array.keep(toArray(vec), f));
}

function reduce(vec, init, f) {
  return Belt_Array.reduce(toArray(vec), init, f);
}

function debug(param) {
  var traverse = function (node, depth) {
    if (node.TAG === /* Node */0) {
      console.log("I " + String(depth));
      return Belt_Array.forEach(node._0, (function (n) {
                    return traverse(n, depth + 1 | 0);
                  }));
    }
    console.log("L " + String(depth));
    return Belt_Array.forEach(node._0, (function (n) {
                  console.log(n);
                  
                }));
  };
  return traverse(param.root, 1);
}

exports.make = make;
exports.length = length;
exports.push = push;
exports.pop = pop;
exports.peek = peek;
exports.get = get;
exports.getExn = getExn;
exports.set = set;
exports.setExn = setExn;
exports.map = map;
exports.keep = keep;
exports.reduce = reduce;
exports.fromArray = fromArray;
exports.toArray = toArray;
exports.debug = debug;
/* No side effect */
