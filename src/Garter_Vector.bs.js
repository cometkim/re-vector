// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Garter_Array = require("./Garter_Array.bs.js");

function numChildren(n) {
  return n._0.length;
}

function hasRoom(node) {
  return node._0.length < 2;
}

function hasSiblings(node) {
  return node._0.length > 1;
}

function makeEmptyInner(param) {
  return {
          TAG: /* Inner */0,
          _0: []
        };
}

function makeEmptyLeaf(param) {
  return {
          TAG: /* Leaf */1,
          _0: []
        };
}

function makeInner(x) {
  return {
          TAG: /* Inner */0,
          _0: Belt_Array.make(1, x)
        };
}

function makeInner2(x, y) {
  var ar = new Array(2);
  ar[0] = x;
  ar[1] = y;
  return {
          TAG: /* Inner */0,
          _0: ar
        };
}

function makeLeaf(x) {
  return {
          TAG: /* Leaf */1,
          _0: Belt_Array.make(1, x)
        };
}

var $$Node = {
  hasRoom: hasRoom,
  hasSiblings: hasSiblings,
  makeEmptyInner: makeEmptyInner,
  makeEmptyLeaf: makeEmptyLeaf,
  makeInner: makeInner,
  makeInner2: makeInner2,
  makeLeaf: makeLeaf
};

function make(param) {
  return {
          size: 0,
          depth: 1,
          root: {
            TAG: /* Leaf */1,
            _0: []
          }
        };
}

function length(v) {
  return v.size;
}

function pow(base, exp) {
  return Math.pow(base, exp) | 0;
}

function getPath(i, depth) {
  if (depth === 0) {
    return {
            hd: i,
            tl: /* [] */0
          };
  }
  var denom = pow(2, depth);
  console.log("denom: " + String(denom));
  return Belt_List.add(getPath(Caml_int32.mod_(i, denom), depth - 1 | 0), Caml_int32.div(i, denom));
}

function getUnsafe(param, i) {
  var path = getPath(i, param.depth - 1 | 0);
  var _path = path;
  var _node = param.root;
  while(true) {
    var node = _node;
    var path$1 = _path;
    var index = Belt_List.headExn(path$1);
    if (node.TAG) {
      return node._0[index];
    }
    _node = node._0[index];
    _path = Belt_List.tailExn(path$1);
    continue ;
  };
}

function get(v, i) {
  if (i < 0 || i >= v.size) {
    return ;
  } else {
    return Caml_option.some(getUnsafe(v, i));
  }
}

function setUnsafe(vec, i, x) {
  var path = getPath(i, vec.depth - 1 | 0);
  var traverse = function (path, node) {
    var index = Belt_List.headExn(path);
    if (node.TAG) {
      var m = node._0.slice(0);
      m[index] = x;
      return {
              TAG: /* Leaf */1,
              _0: m
            };
    }
    var n = node._0;
    var m$1 = n.slice(0);
    m$1[index] = traverse(Belt_List.tailExn(path), n[index]);
    return {
            TAG: /* Inner */0,
            _0: m$1
          };
  };
  return {
          size: vec.size,
          depth: vec.depth,
          root: traverse(path, vec.root)
        };
}

function getLastLeaf(param) {
  var _node = param.root;
  while(true) {
    var node = _node;
    if (node.TAG) {
      return node;
    }
    var n = node._0;
    _node = n[n.length - 1 | 0];
    continue ;
  };
}

function isRootOverflow(param) {
  return param.size === pow(2, param.depth);
}

function debug(param) {
  var traverse = function (node, depth) {
    if (node.TAG) {
      console.log("L " + String(depth));
      return Belt_Array.forEach(node._0, (function (n) {
                    console.log(n);
                    
                  }));
    }
    console.log("I " + String(depth));
    return Belt_Array.forEach(node._0, (function (n) {
                  return traverse(n, depth + 1 | 0);
                }));
  };
  return traverse(param.root, 1);
}

function push(vec, x) {
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  if (hasRoom(getLastLeaf(vec))) {
    var traverse = function (node) {
      if (node.TAG) {
        var ar = node._0;
        var newAr = ar.slice(0);
        newAr[ar.length] = x;
        return {
                TAG: /* Leaf */1,
                _0: newAr
              };
      }
      var ar$1 = node._0;
      var newAr$1 = ar$1.slice(0);
      newAr$1[ar$1.length - 1 | 0] = traverse(Garter_Array.lastUnsafe(ar$1));
      return {
              TAG: /* Inner */0,
              _0: newAr$1
            };
    };
    var newRoot = traverse(root);
    return {
            size: size + 1 | 0,
            depth: vec.depth,
            root: newRoot
          };
  }
  if (isRootOverflow(vec)) {
    var newPath = function (_depth, _node) {
      while(true) {
        var node = _node;
        var depth = _depth;
        if (depth === 0) {
          return node;
        }
        _node = {
          TAG: /* Inner */0,
          _0: Belt_Array.make(1, node)
        };
        _depth = depth - 1 | 0;
        continue ;
      };
    };
    var newRoot$1 = makeInner2(root, newPath(depth - 1 | 0, {
              TAG: /* Leaf */1,
              _0: Belt_Array.make(1, x)
            }));
    return {
            size: size + 1 | 0,
            depth: depth + 1 | 0,
            root: newRoot$1
          };
  }
  var traverse$1 = function (node, height) {
    if (node.TAG) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Garter_Vector.re",
              218,
              21
            ],
            Error: new Error()
          };
    }
    var ar = node._0;
    if (height === 1) {
      return {
              TAG: /* Leaf */1,
              _0: Belt_Array.make(1, x)
            };
    }
    if (hasRoom(node)) {
      var newAr = new Array(ar.length + 1 | 0);
      Belt_Array.blit(ar, 0, newAr, 0, ar.length);
      newAr[ar.length] = traverse$1({
            TAG: /* Inner */0,
            _0: []
          }, height - 1 | 0);
      return {
              TAG: /* Inner */0,
              _0: newAr
            };
    }
    var last = Garter_Array.lastUnsafe(ar);
    var newAr$1 = ar.slice(0);
    newAr$1[ar.length - 1 | 0] = traverse$1(last, height - 1 | 0);
    return {
            TAG: /* Inner */0,
            _0: newAr$1
          };
  };
  var newRoot$2 = traverse$1(root, depth);
  return {
          size: size + 1 | 0,
          depth: vec.depth,
          root: newRoot$2
        };
}

function pop(vec) {
  var root = vec.root;
  var depth = vec.depth;
  var size = vec.size;
  var leaf = getLastLeaf(vec);
  if (hasSiblings(leaf)) {
    var traverse = function (node) {
      if (node.TAG) {
        var ar = node._0;
        var newAr = Belt_Array.slice(ar, 0, ar.length - 1 | 0);
        return {
                TAG: /* Leaf */1,
                _0: newAr
              };
      }
      var ar$1 = node._0;
      var newAr$1 = ar$1.slice(0);
      newAr$1[ar$1.length - 1 | 0] = traverse(Garter_Array.lastUnsafe(ar$1));
      return {
              TAG: /* Inner */0,
              _0: newAr$1
            };
    };
    var newRoot = traverse(root);
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: newRoot
          };
  }
  var path = getPath(size - 1 | 0, depth);
  var traverse$1 = function (path, curNode) {
    var subIdx = Belt_List.headExn(path);
    if (curNode.TAG) {
      if (subIdx !== 0) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Garter_Vector.re",
                288,
                10
              ],
              Error: new Error()
            };
      }
      return ;
    }
    var ar = curNode._0;
    var child = traverse$1(Belt_List.tailExn(path), ar[subIdx]);
    if (child !== undefined) {
      var newAr = ar.slice(0);
      newAr[subIdx] = {
        TAG: /* Inner */0,
        _0: Belt_Array.make(1, child)
      };
      return {
              TAG: /* Inner */0,
              _0: newAr
            };
    }
    if (subIdx === 0) {
      return ;
    }
    var newAr$1 = Belt_Array.slice(ar, 0, ar.length - 1 | 0);
    return {
            TAG: /* Inner */0,
            _0: newAr$1
          };
  };
  var newRoot$1 = traverse$1(path, root);
  if (newRoot$1 !== undefined) {
    if (!newRoot$1.TAG && !hasSiblings(newRoot$1)) {
      var firstChild = newRoot$1._0[0];
      return {
              size: size - 1 | 0,
              depth: depth - 1 | 0,
              root: firstChild
            };
    }
    return {
            size: size - 1 | 0,
            depth: vec.depth,
            root: newRoot$1
          };
  }
  if (size !== 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.re",
            302,
            8
          ],
          Error: new Error()
        };
  }
  if (depth !== 2) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Garter_Vector.re",
            303,
            8
          ],
          Error: new Error()
        };
  }
  return {
          size: 0,
          depth: 1,
          root: {
            TAG: /* Leaf */1,
            _0: []
          }
        };
}

function fromArray(ar) {
  return Belt_Array.reduce(ar, {
              size: 0,
              depth: 1,
              root: {
                TAG: /* Leaf */1,
                _0: []
              }
            }, push);
}

var numBranches = 2;

exports.numBranches = numBranches;
exports.numChildren = numChildren;
exports.$$Node = $$Node;
exports.make = make;
exports.length = length;
exports.pow = pow;
exports.getPath = getPath;
exports.getUnsafe = getUnsafe;
exports.get = get;
exports.setUnsafe = setUnsafe;
exports.getLastLeaf = getLastLeaf;
exports.isRootOverflow = isRootOverflow;
exports.debug = debug;
exports.push = push;
exports.pop = pop;
exports.fromArray = fromArray;
/* No side effect */
